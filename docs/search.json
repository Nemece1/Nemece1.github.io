[
  {
    "objectID": "wisconsin_districts.html",
    "href": "wisconsin_districts.html",
    "title": "Congressional Districs of Wisconsin",
    "section": "",
    "text": "Wisconsin’s susceptibility to gerrymandering arises from its identity as a swing state characterized by contested elections. The state’s distinct urban-rural disparity offers fertile ground for biased manipulation of electoral boundaries, prompting concerns regarding equal representation. To show these suspicions, we have leveraged data sourced from congressional district shape files for the 113th Congress, obtained from a UCLA website, and overlaid them onto the geographical borders of Wisconsin’s congressional districts. The table below provides a breakdown of the eight congressional districts alongside the respective percentages of Republican voters in each district.\n\n\n\n\n\ndistrict\nr_prop\nwinner\n\n\n\n\n5\n0.6676090\nRepublican\n\n\n1\n0.6499393\nRepublican\n\n\n8\n0.6268105\nRepublican\n\n\n7\n0.6170728\nRepublican\n\n\n6\n0.5719445\nRepublican\n\n\n2\n0.3119968\nDemocrat\n\n\n3\n0.0000000\nDemocrat\n\n\n4\n0.0000000\nDemocrat\n\n\n\n\n\nWe observe a trend where Republican districts secure victories by narrow margins, contrasting with Democratic districts that either lack Republican voters entirely or win their districts uncontested. This suggests a potential instance of gerrymandering, where the state is strategically divided, concentrating Democratic voters into a single area to account for only one electoral representative, while Republicans dominate the majority of other districts.\nThese plots show the political party of each winning district as well as their shape and size relative to the state as well as the other districts.\n\n\nWarning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\ngive correct results for longitude/latitude data"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Courses at St. Olaf College",
    "section": "",
    "text": "I have taken the following MSCS courses during my time at St. Olaf College\n\nCalculus 2:\n\nTechniques of integration including substitution, integration by parts, and partial fractions.\nApplications of integration such as finding areas, volumes, and arc lengths.\nSequences and series including convergence tests and Taylor series.\n\nCalculus 3:\n\nMultivariable calculus including partial derivatives, multiple integrals, and line integrals.\nVector calculus concepts like gradients, divergence, and curl.\nApplications such as optimization problems and parametric surfaces.\n\nProbability Theory:\n\nFundamentals of probability including probability spaces, random variables, and probability distributions.\nProbability rules like Bayes’ theorem and the law of total probability.\nBasic concepts of statistics including expected value, variance, and probability distributions.\n\nLinear Algebra:\n\nVector spaces, subspaces, and linear transformations.\nMatrix operations including addition, multiplication, and inverses.\nEigenvalues and eigenvectors, diagonalization, and applications such as solving systems of linear equations.\n\nData Science 1:\n\nIntroduction to R programming language and RStudio environment for data analysis.\nPrinciples of data tidying and manipulation using tools like the tidyverse package.\nBuilding personal data analysis projects from data acquisition and cleaning to visualization and interpretation.\n\nData Science 2:\n\nIn progress\n\nStatistics 1:\n\nDescriptive statistics including measures of central tendency and dispersion.\nProbability distributions and their properties.\nStatistical inference including hypothesis testing and confidence intervals."
  },
  {
    "objectID": "Projects.html",
    "href": "Projects.html",
    "title": "Understanding Medications: Uncovering Side Effects",
    "section": "",
    "text": "This is Understanding Medications: Uncovering Side Effects.\n\nThe past year and a half I have been studying the essential skills in R such as Data visualization, tidying, transformation. Over this time I have practiced my coding skills using joins, factors, strings and other workflow basics. In the fall of 2023 Jackson Marsh and I conducted a study on the side effects of popular prescription drugs and the cautions of drug interactions."
  },
  {
    "objectID": "us_states.html",
    "href": "us_states.html",
    "title": "Geospatial Maping of Obesity In The United States",
    "section": "",
    "text": "My dataset comprises national obesity percentages categorized by state. The “Obesity” field attribute denotes the percentage of each state’s population classified as obese, based on the 2015 CDC BRFSS Survey. For this analysis, I focused on obesity percentages. The dataset I’m joining with provides latitude and longitude coordinates for each state. To merge the obesity percentages with their corresponding latitude and longitude coordinates, I performed a right join. It’s necessary to convert the state names to lowercase using the str_to_lower function because they are capitalized in the “StateObesity” tibble but are lowercase in the “us_states” tibble, ensuring accurate matching between the datasets.\n\n\n\n\n\nThe plot reveals distinct patterns in state obesity rates. Colorado stands out with the lowest average obesity rate, while Louisiana appears to have the highest. Along the West Coast, as well as in other regions, darker blue and purple hues dominate, indicating relatively lower obesity rates. Conversely, the southeastern part of the country is characterized by bright yellow shades, signifying a notably higher average obesity rate in those states."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lance Nemecek",
    "section": "",
    "text": "Student of Mathematics and Data Science  MSCS Department @ St. Olaf College\n\n\nHigh school Degree | Mound Westonka High School\nIn progress: BA in Math with Stats and Data Science concentration 2026 | St. Olaf College\n\n\n\nServer | Woodhill Country Club\nMetal Fabricator | Industrial Louvers\nFood Expoditor | Maynards Restaurant"
  },
  {
    "objectID": "index.html#lance-nemecek",
    "href": "index.html#lance-nemecek",
    "title": "Lance Nemecek",
    "section": "",
    "text": "Student of Mathematics and Data Science  MSCS Department @ St. Olaf College\n\n\nHigh school Degree | Mound Westonka High School\nIn progress: BA in Math with Stats and Data Science concentration 2026 | St. Olaf College\n\n\n\nServer | Woodhill Country Club\nMetal Fabricator | Industrial Louvers\nFood Expoditor | Maynards Restaurant"
  },
  {
    "objectID": "Projectsland.html",
    "href": "Projectsland.html",
    "title": "Projects",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nUnderstanding Medications: Uncovering Side Effects\n\n\n\n\n\n\n\nMedicine\n\n\nData Science\n\n\n\n\nLance Nemecek and Jackson Marsh\n\n\n\n\n \n\n\n\n\nNo matching items"
  },
  {
    "objectID": "Mini Project 2/BirthdayParadox.html",
    "href": "Mini Project 2/BirthdayParadox.html",
    "title": "Birthday Problem",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nThe Birthday Problem The birthday paradox, often termed as the birthday problem, is a perplexing phenomenon in probability theory that challenges common intuitions regarding the likelihood of shared birthdays within a group of individuals. Contrary to what one might expect, the paradox posits that in a relatively small gathering, the probability of at least two people sharing the same birthday is surprisingly high. This paradox arises due to the counterintuitive nature of combinatorial probabilities, where the focus shifts from the likelihood of a specific individual sharing a birthday with another to the broader scenario of any two individuals sharing a birthday within the group. Through combinatorial analysis and application of the principle of inclusion-exclusion, the birthday paradox unveils that as the number of individuals increases, the probability of shared birthdays escalates at a much faster rate than anticipated, reaching a point where it becomes highly probable, even in seemingly small groups. This paradox holds significant implications in various fields, including cryptography, networking, and epidemiology, where understanding the underlying principles of probability is crucial for accurate risk assessment and decision-making.\nWhat we know We know in advance that the answer should be 23 birthdays should give us a 50% probability that two of the people in our sample will have the same birthday. We wrote this is code by taking a sample of 1 though 366 represeting the days of the year, and then taking a random sample of 23 numbers. We must incluce replace = TRUE or else R will give us distinct values.\n\nbirthdays &lt;- sample(1:366, 23, replace = TRUE) \n\nWe make a dataset from our function so we can work with the same data for a little bit while doing out statistical analysis. The duplicated function is helpful in this case as it can find when two numbers in the same output set are the same. It will return a list of trues and falses. If two numbers are the same, the function will return a false for the first time that number appeasers but will return TRUE for the second time that number appears.\nBoolean vales in R are handy because they are read as either a 1 or a zero. That means we can use the max function to see if there was a match. If the function returns a 0 then there were no matching birthdays and if it retuns a 1 then there were matching birthdays.\n\nbirthdays &lt;- sample(1:366, 23, replace = TRUE) \n\nbirthdays |&gt;\n  duplicated()\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\nbirthdays |&gt;\n  duplicated() |&gt;\n  max()\n\n[1] 1\n\n\n\nUsing a for loop for mass repetition\nThe for loop iterates over the numbers 1 to 10000.\nWithin each iteration: 1. It generates a sample of 23 birthdays representing possible days in a year with replacement. 2. It checks for duplicated birthdays within the sample. 3. It assigns the result of whether duplicates were found TRUE or FALSE to the corresponding row in the match column of the matches data frame.\n\nmatches &lt;- data.frame(rep = 1:10000, match = NA)\n\nfor(i in 1:10000){\n  \nbirthdays &lt;- sample(1:366, 23, replace = TRUE) \n\nmatches$match[i] &lt;- birthdays |&gt;\n  duplicated() |&gt;\n  max() \n}\n\nmatches |&gt;\n  summarize(mean(match),\n            se = sd(match)/sqrt(10000))\n\n  mean(match)         se\n1      0.5114 0.00499895\n\n\n#Creating a function\nThe function I titled birthday_problem, takes two parameters: people and iterations, representing the number of iterations to perform with the default being 10,000.\nWithin the function: 1. It initializes a data frame called matches with two columns: rep and match, with rep ranging from 1 to the specified number of iterations, and match initially filled with NA values. 2. It iterates over the specified number of iterations, again the defualt being 10,000. 3. Within each iteration - Refer to the for loop :) 4. After all iterations, it calculates the mean of the match column, standard error, and includes information about the number of people and iterations. 5. It returns a summary data frame containing the mean, standard error, number of people, and number of iterations.\n\nbirthday_problem &lt;- function(people, iterations = 10000) {\n\nmatches &lt;- data.frame(rep = 1:iterations, match = NA)\n\nfor(i in 1:iterations){\n  \nbirthdays &lt;- sample(1:366, people, replace = TRUE) \n\nmatches$match[i] &lt;- birthdays |&gt;\n  duplicated() |&gt;\n  max() \n}\n\nmatches |&gt;\n  summarize(mean1 = mean(match),\n            se = sd(match)/sqrt(iterations), \n            people = people, \n            iterations = iterations)\n}\n\n#Easy way to run\nThe function, when called with people = 23, simulates the birthday problem scenario for 23 people. It generates random samples of 23 birthdays, checks for duplicates within each sample, and repeats this process for 10,000 iterations by default as explained earlier. The output will be a summary data frame with the mean probability, standard error, number of people, and number of iterations.\n\nbirthday_problem(23)\n\n   mean1          se people iterations\n1 0.5022 0.005000202     23      10000\n\n\n#Preparing to graph\nThis R code iterates over the numbers from 1 to 50, calling the birthday_problem function for each number, and storing the results in a list called results_list.\nFor each iteration: 1. It calls the birthday_problem function with the current number (people_input) as the argument. 2. It appends the result. In other words, a summary data frame containing mean probability, standard error, number of people, and number of iterations to the results_list.\nAfter iterating over all numbers from 1 to 50, it combines all the summary data frames stored in results_list into a single data frame called results_birthday using do.call(rbind, results_list). This binds all the rows together into one data frame, stacking the results for each number of people on top of each other.\n\nresults_list &lt;- list()\n\nfor (people_input in seq(1, 50)) {\n  results_list[[length(results_list) + 1]] &lt;- birthday_problem(people_input)\n}\n\nresults_birthday &lt;- do.call(rbind, results_list)\n\nThe results_birthday data frame is used as the data source for the plot.\n\nggplot(results_birthday, aes(x = people, y = mean1))+\n  geom_point() +\n  labs(x = \"Number of People\", y = \"Probability of Shared Birthday\",\n       title = \"Birthday Problem\") +\n  theme_minimal()\n\n\n\n\n\nggplot(results_birthday, aes(x = people, y = mean1)) +\n  geom_point(color = \"blue\", size = 2, alpha = 0.7) + \n  labs(x = \"Number of People\", y = \"Probability of Shared Birthday\",\n       title = \"Probability of Shared Birthday vs. Number of People\", \n       subtitle = \"Simulation of the Birthday Problem\", \n       caption = \"Data Source: Simulation with 10,000 Iterations\") +  \n  theme_minimal() + \n  theme(legend.position = \"none\",\n        plot.title = element_text(size = 12, face = \"bold\"),  \n        plot.subtitle = element_text(size = 12), \n        plot.caption = element_text(size = 9))"
  },
  {
    "objectID": "BirthdayParadox.html",
    "href": "BirthdayParadox.html",
    "title": "The Birthday Problem",
    "section": "",
    "text": "Background\nThe Birthday Problem The birthday paradox, often termed as the birthday problem, is a perplexing phenomenon in probability theory that challenges common intuitions regarding the likelihood of shared birthdays within a group of individuals. Contrary to what one might expect, the paradox posits that in a relatively small gathering, the probability of at least two people sharing the same birthday is surprisingly high. This paradox arises due to the counterintuitive nature of combinatorial probabilities, where the focus shifts from the likelihood of a specific individual sharing a birthday with another to the broader scenario of any two individuals sharing a birthday within the group. Through combinatorial analysis and application of the principle of inclusion-exclusion, the birthday paradox unveils that as the number of individuals increases, the probability of shared birthdays escalates at a much faster rate than anticipated, reaching a point where it becomes highly probable, even in seemingly small groups. This paradox holds significant implications in various fields, including cryptography, networking, and epidemiology, where understanding the underlying principles of probability is crucial for accurate risk assessment and decision-making.\nWhat we know We know in advance that the answer should be 23 birthdays should give us a 50% probability that two of the people in our sample will have the same birthday. We wrote this is code by taking a sample of 1 though 366 represeting the days of the year, and then taking a random sample of 23 numbers. We must incluce replace = TRUE or else R will give us distinct values.\n\nbirthdays &lt;- sample(1:366, 23, replace = TRUE) \n\n\n\nMaking Dataset\nWe make a dataset from our function so we can work with the same data for a little bit while doing out statistical analysis. The duplicated function is helpful in this case as it can find when two numbers in the same output set are the same. It will return a list of trues and falses. If two numbers are the same, the function will return a false for the first time that number appeasers but will return TRUE for the second time that number appears.\nBoolean vales in R are handy because they are read as either a 1 or a zero. That means we can use the max function to see if there was a match. If the function returns a 0 then there were no matching birthdays and if it retuns a 1 then there were matching birthdays.\n\nbirthdays &lt;- sample(1:366, 23, replace = TRUE) \n\nbirthdays |&gt;\n  duplicated()\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE\n\nbirthdays |&gt;\n  duplicated() |&gt;\n  max()\n\n[1] 1\n\n\n\n\nUsing a for loop for mass repetition\nThe for loop iterates over the numbers 1 to 10000.\nWithin each iteration: 1. It generates a sample of 23 birthdays representing possible days in a year with replacement. 2. It checks for duplicated birthdays within the sample. 3. It assigns the result of whether duplicates were found TRUE or FALSE to the corresponding row in the match column of the matches data frame.\n\nmatches &lt;- data.frame(rep = 1:10000, match = NA)\n\nfor(i in 1:10000){\n  \nbirthdays &lt;- sample(1:366, 23, replace = TRUE) \n\nmatches$match[i] &lt;- birthdays |&gt;\n  duplicated() |&gt;\n  max() \n}\n\nmatches |&gt;\n  summarize(mean(match),\n            se = sd(match)/sqrt(10000))\n\n  mean(match)          se\n1      0.5017 0.005000221\n\n\n\n\nCreating a function\nThe function I titled birthday_problem, takes two parameters: people and iterations, representing the number of iterations to perform with the default being 10,000.\nWithin the function: 1. It initializes a data frame called matches with two columns: rep and match, with rep ranging from 1 to the specified number of iterations, and match initially filled with NA values. 2. It iterates over the specified number of iterations, again the defualt being 10,000. 3. Within each iteration - Refer to the for loop :) 4. After all iterations, it calculates the mean of the match column, standard error, and includes information about the number of people and iterations. 5. It returns a summary data frame containing the mean, standard error, number of people, and number of iterations.\n\nbirthday_problem &lt;- function(people, iterations = 10000) {\n\nmatches &lt;- data.frame(rep = 1:iterations, match = NA)\n\nfor(i in 1:iterations){\n  \nbirthdays &lt;- sample(1:366, people, replace = TRUE) \n\nmatches$match[i] &lt;- birthdays |&gt;\n  duplicated() |&gt;\n  max() \n}\n\nmatches |&gt;\n  summarize(mean1 = mean(match),\n            se = sd(match)/sqrt(iterations), \n            people = people, \n            iterations = iterations)\n}\n\n\n\nEasy way to run\nThe function, when called with people = 23, simulates the birthday problem scenario for 23 people. It generates random samples of 23 birthdays, checks for duplicates within each sample, and repeats this process for 10,000 iterations by default as explained earlier. The output will be a summary data frame with the mean probability, standard error, number of people, and number of iterations.\n\nbirthday_problem(23)\n\n   mean1          se people iterations\n1 0.5115 0.004998927     23      10000\n\n\n\n\nPreparing to graph\nThis R code iterates over the numbers from 1 to 50, calling the birthday_problem function for each number, and storing the results in a list called results_list.\nFor each iteration: 1. It calls the birthday_problem function with the current number (people_input) as the argument. 2. It appends the result. In other words, a summary data frame containing mean probability, standard error, number of people, and number of iterations to the results_list.\nAfter iterating over all numbers from 1 to 50, it combines all the summary data frames stored in results_list into a single data frame called results_birthday using do.call(rbind, results_list). This binds all the rows together into one data frame, stacking the results for each number of people on top of each other.\n\nresults_list &lt;- list()\n\nfor (people_input in seq(1, 50)) {\n  results_list[[length(results_list) + 1]] &lt;- birthday_problem(people_input)\n}\n\nresults_birthday &lt;- do.call(rbind, results_list)\n\nThe results_birthday data frame is used as the data source for the plot.\n\nggplot(results_birthday, aes(x = people, y = mean1)) +\n  geom_point(color = \"blue\", size = 2, alpha = 0.7) + \n  labs(x = \"Number of People\", y = \"Probability of Shared Birthday\",\n       title = \"Probability of Shared Birthday vs. Number of People\", \n       subtitle = \"Simulation of the Birthday Problem\", \n       caption = \"Data Source: Simulation with 10,000 Iterations\") +  \n  theme_minimal() + \n  theme(legend.position = \"none\",\n        plot.title = element_text(size = 12, face = \"bold\"),  \n        plot.subtitle = element_text(size = 12), \n        plot.caption = element_text(size = 9))"
  }
]